Task description:

1) do Chapter 8

2) answer the questions

  1.  Что можете рассказать о реализации безопасности в Спринг и роли сервлет фильтров в этом?

  2.  Аутентификация и авторизация, в чем разница?

  3.  Объяснить назначение 5 основных объектов таких как UserDetailsService, SecutityContextHolder, Authentication и тд

  4.  От каких OWASP спринг может нам помочь защититься?

  5.  Кто такие Resource owner и Client в OAuth? 

  6.  OAuth 2. Для каких задач вы бы использовали Resource owner credentials grant, а для каких Client credentials grant?

  7.  OAuth 2. Чем implicit grant отличается от authorization code grant, и почему по вашему его назвали implicit?

  8.  OAuth 2. Представим, что есть социальная сеть MyNet похожая на Твиттер. И вам выдано задание написать приложение UrStats которое подсчитывает среднее количество символов в постах пользователя и другие параметры. Перечислите детально шаги, которые необходимо проделать приложению от захода пользователя на сайт urstats.com до вывода ему статистики постов.

  9.  Есть класс HttpSecurity. Какой формат настройки авторизации эндпоинтов через этот класс и для чего методы and(), authorizeRequests(), csrf().

  10. OAuth 2 с JWT, в чем преимущество? От каких шагов избавляемся, ценой чего? Формат JWT. Вручную составить JWT access и refresh токен для api.forum.com/QuickPoll со всеми полями из RFC 7519.

  11. Для чего @PreAuthorize?

  12. * Настроить безопасность для QuickPoll и ролей VISITOR (только голосование), STAFF (только просмотр результатов), ADMIN (все операции). Method Security.

3) Create MR and send the link.

-----
-----

Quiz answers:

1. Spring Security обеспечивает интеграцию с разными системами аутентификации и имеет встроенные элементы защиты от атак в сети. Также позволяет довольно гибко настроить безопасность приложения. Перед тем, как запрос попадет в нужный метод контроллера, он проходит через сервлет фильтры, которые позволяют проверить запрос или модифицировать его до обработки самим приложением.

2. Аутентификация - проверка подлинности, авторизация - предоставление прав на выполнение определенный действий.

3. Основыные обьекты, используемые в Spring Security при аутентификации/авторизации:

    - *UserDetailsService* позволяет получить данные о пользователе, в частности о его правах.
    - *SecutityContextHolder* является связующим звеном между контекстом пользователя и процессом выполнения запроса.
    - *Authentication* - содержит данные о аутентификации;
    - *AuthenticationManger* преобразовывает токен запроса аутентификации в готовый экземпляр Authentication.
    - *AbstractSecurityInterceptor* используется для проверки, имеет ли пользователь доступ к защищенныым данным.

4. Spring Security помогает защититься от:

    - Broken Authentication and Session Management (A2),
    - Insecure Direct Object References (A4),
    - Sensitive Data Exposure (A6),
    - Missing Function Level Access Control (A7),
    - Cross-Site Request Forgery (A8).

5. *Resource owner* - пользователь, *Client* - приложение (зачастую стороннее) для доступа к ресурсам, которые находятся на сервере.

6. *Resource owner credentials grant* обычно используется для доступа к ресурсам, а *Client credentials grant* - для получения дополнительных данных.

7. *Implicit grant*, в отличие от *authorization code grant*, позволяет сразу получить *access token* сразу, без дополнительного обмена авторизационного кода. Название такое, скорее всего, из-за того что нет необходимости сообщать Resource owner'у о получении доступа к ресурсам.

8. Для получения статистики будут произведены следующие действия:

    - получение запроса от пользователя,
    - составление тела запроса для MyNet,
    - проверка наличия действительного токена для доступа *UrStats* к *MyNet*,
    - если такого токена нет, его получение,
    - добавление токена авторизации к запросу,
    - отправка запроса в *MyNet*,
    - анализ полученных постов,
    - отправка пользователю результата анализа.

9. *HttpSecurity* позволяет настроить безопасность для веб-запросов. *and()* указывает, что текущая ветка настройки закончена и нужно добавить еще одну. *authorizeRequests()* позволяет ограничить доступ для определенных запросов, соответствующих указанным в матчере (как правило следующий метод). *csrf()* добавляет поддержку подделки запросов.

10. *JWT* состоит из трех частей: заголовок, данные и подпись. Пример заголовка в формате JSON: *{ "alg": "HS256", "typ": "JWT" }*. Пример данных: *{ "username": "mickey", "exp": "42874" }*. Для создания подписи кодируем заголовок и данные через *base64urlEncode()*, соединяем их через точку, а затем хешируем то, что получилось, алгоритмом, указанным в заголовке на основе секретного ключа (допустим "top_secret"). Далее соединяем через точку закодированные через *base64urlEncode()* заголовок, данные и подпись - получаем токен авторизации (при указанных выше исходных данных токен **eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Im1pY2tleSIsImV4cCI6IjQyODc0In0.5L67ASAbugoEekOGaFYd_Kae9381pXDoIvj1GsnbIdQ**). *Refresh token* создается аналогично. При том же заголовке и ключе с данными *{ "username": "mickey", "sub": "refresh" }* *refresh token* будет **eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6Im1pY2tleSIsInN1YiI6InJlZnJlc2gifQ.3B_OihmuY88lAdVaM02KPCVJFr7kybIJIQWZfeubrW4**. 

11. *@PreAuthorize* показывает, что для доступа к эндпойнту клиент должен быть авторизированным под аккаунтом с определенной ролью.

12. Добавлено в код